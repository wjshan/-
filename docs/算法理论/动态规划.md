# 动态规划
动态规划问题一般用于解决求最值问题,其核心在于穷举.穷举全部可能性,然后找出最优解.

暴力枚举是解决此类问题的第一步,如果能想出暴力求解的方法,则后续仅需要优化解法,即可接近最优的时间复杂度和和空间复杂度.



## 状态转移方程

当我们先假设这个结论在$n<k$时成立,然后根据这个假设,那么想办法推出当$n=k$是这个结论也成立.如果能够证明出来,那么就可以说这个假设成立.

类似的,当我们需要求解d$p[i]$时,可以假定$dp[0\dots i-1]$都已经被算出来了,然后考虑怎么从$dp[0\dots i-1]$得出$dp[i]$.其中dp指的就是状态转移数组,从$dp[0\dots i-1]$得出$dp[i]$的过程就是状态转移方程.

设计状态转移方程的过程为:**明确基础数据 -> 明确[状态] -> 明确[选择] -> 定义`dp`数组的含义**


## 最优子结构
**从子问题的最优结果推出更大问题的最优结果.**
当子问题不符合**互相独立**的原则时,则不属于最优子结构.




## 备忘录
备忘录可以视为一个中间结果的缓存`map`

如果是采用递归解决问题,不可避免的会遇到重复计算*子问题*的情况.此时在计算一个子问题前可以先到*备忘录*中查找这个子问题是否已经被计算过,如果备忘录中有相关的计算结果,则直接返回此结果.反之则在计算子问题之后,将当前子问题的结果放入备忘录中.

**备忘录是一种用空间换时间的方法.**

在某些问题中,备忘录能极大提高计算速度.例如求解斐波那契数列问题,$f(i)=\begin{cases}
    1 &i=1 \\
    1&i=2 \\
    f(i-1)+f(i-2)&i>2
\end{cases}$

```py3 title="不使用备忘录"
def fib(n:int)->int:
    if n in [1, 2]:
        return 1
    return fib(n-1)+fib(n-2)

if __name__ == '__main__':
    fib(30) # 耗时0.9秒
```
递归树如下:
![图解](https://labuladong.github.io/algo/images/%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%e8%af%a6%e8%a7%a3%e8%bf%9b%e9%98%b6/1.jpg)

在不使用备忘录时,程序需要遍历递归树上全部节点才能得出结果.时间复杂度为$O(2^N)$

```py3 title="使用备忘录"
def fib(n:int, cache_map:Dict=None)->int:
    cache_map = cache_map or {1: 1, 2: 2}
    if n in cache_map:
        return cache_map[n]
    ans = fib(n-1,cache_map)+fib(n-2,cache_map)
    cache_map[n] = ans
    return ans

if __name__ == '__main__':
    fib(30) # 耗时0.00007秒
```
使用递归树之后,程序对已经得出结果的节点不再向下生长.程序仅需要计算每个节点的左子树即可完成.时间复杂度为$O(N)$

## 无后效性